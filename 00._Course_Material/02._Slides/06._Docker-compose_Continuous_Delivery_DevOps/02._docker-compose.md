<div class="title-card">
    <h1>Docker-compose</h1>
</div>


---

# Recap from last semester

The assumption is that you have already with docker-compose. 

Recap of what it is:

We can define multiple services, networks, and volumes in a single file.

Docker-compose provides a simple singular command to start, stop, and manage multiple containers at once.

---

# Docker-compose vs. Docker compose

`docker-compose` is the separate command-line tool from Docker. It allows us to define and run multi-container Docker applications. Written in Python.

A more recent attempt has been made to include docker compose functionality in the Docker CLI. The plugin can be invoked with `docker compose`. Rewritten in Go.

If you want to use `docker-compose` you will have to install it separately. (`brew install docker-compose`, `choco install docker-compose`, etc.)

---

# Docker-compose and Docker compose are not interchangeable

Given this compose file:

```Dockefile
services:
  web:
    build: ./node_project
```

`$ docker-compose build web` will generate the following image tag: `node_project_web`

`$ docker compose build web` will generate the following image tag: `node_project-web`

Notice the hyphens and underscores. 

This will matter if you are using the image name in your setup. In all of the course material, I will use `docker-compose` for consistency.

---

# Let's explore at a compose file

Are you familiar with `Awesome Compose`?

*Look at this file below and try to understand it line by line*

https://github.com/docker/awesome-compose/blob/master/spring-postgres/compose.yaml

Feel free to discuss it with people around you.

---

# Quick quiz

```yaml
services:
  web:
    build: .
    ports:
      - "8000:8000"
  db:
    image: postgres
    ports:
      - "8001:5432"
```

*Where is the Dockerfile defined? How do you know?*

<details> 
  <summary>Answer</summary>
  It is defined in the same directory as the compose file.
</details>


*What is the default port for PostgreSQL? What is the other number for?*

<details> 
  <summary>Answer</summary>
  Default port for PostgreSQL is `5432`. 
  The other number, `8001`, is the port that the container will expose i.e. the port you can connect to the database from the outside.
</details>

---

# [Networking](https://docs.docker.com/compose/networking/)

For example, suppose your app is in a directory called `myapp`, and your compose file looks like this:

```yaml
services:
  web:
    build: .
    ports:
      - "8000:8000"
  db:
    image: postgres
    ports:
      - "8001:5432"
```

When you run docker compose up, the following happens:

1. A network called `myapp_default` is created.
2. A container is created using web's configuration. It joins the network `myapp_default` under the name web.
3. A container is created using db's configuration. It joins the network `myapp_default` under the name db.

---

# Volumes vs. Bind mounts

> "Volumes are the preferred mechanism for persisting data generated by and used by Docker containers. While bind mounts are dependent on the directory structure and OS of the host machine, volumes are completely managed by Docker."

> "a volume doesn't increase the size of the containers using it, and the volume's contents exist outside the lifecycle of a given container."

[Source - Docker Docs](https://docs.docker.com/engine/storage/volumes/)

---

# Volume example with Nginx

**Problem**: We want to define a configuration file for nginx.

**Solution 1**: Mount your configuration file when running the container:

```bash
$ docker run --name my-custom-nginx-container -v /host/path/nginx.conf:/etc/nginx/nginx.conf:ro -d nginx
```

[Source - DockerHub](https://hub.docker.com/_/nginx/)

**Solution 2**: Build a custom image with the configuration file:

```Dockerfile
FROM nginx
COPY nginx.conf /etc/nginx/nginx.conf
```

```bash
$ docker build -t my-custom-nginx .
$ docker run --name my-custom-nginx-container -d my-custom-nginx
```

---

# Cleaning up

## Clean up

```bash
$ docker compose rm -v
```

## Nuclear clean up

```bash
$ docker stop $(docker ps -q)
$ docker rm $(docker ps -aq)
$ docker system prune -a --volumes -f
```

